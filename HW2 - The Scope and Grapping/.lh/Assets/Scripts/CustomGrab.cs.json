{
    "sourceFile": "Assets/Scripts/CustomGrab.cs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 26,
            "patches": [
                {
                    "date": 1739226573092,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1739226654063,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,58 +2,35 @@\n using UnityEngine.XR.Interaction.Toolkit;\r\n \r\n public class CustomGrab : XRGrabInteractable\r\n {\r\n-    private Vector3 initialAttachLocalPos;\r\n+    private Transform initialAttachLocalPos;\r\n     private Quaternion initialAttachLocalRot;\r\n \r\n-    public bool doubleRotationSpeed = false;\r\n-    private XRBaseInteractor secondInteractor;\r\n-    private Quaternion attachRotationDelta;\r\n-\r\n     protected override void OnSelectEntered(SelectEnterEventArgs args)\r\n     {\r\n         base.OnSelectEntered(args);\r\n-        if (selectingInteractor != null && secondInteractor == null)\r\n-        {\r\n-            // Save the initial attach points\r\n-            initialAttachLocalPos = args.interactor.attachTransform.localPosition;\r\n-            initialAttachLocalRot = args.interactor.attachTransform.localRotation;\r\n-        }\r\n-        else\r\n-        {\r\n-            secondInteractor = args.interactor;\r\n-            attachRotationDelta = Quaternion.Inverse(initialAttachLocalRot) * args.interactor.attachTransform.localRotation;\r\n-        }\r\n+        initialAttachLocalPos = args.interactorObject.transform;\r\n+        initialAttachLocalRot = args.interactorObject.transform.localRotation;\r\n     }\r\n \r\n     protected override void OnSelectExited(SelectExitEventArgs args)\r\n     {\r\n         base.OnSelectExited(args);\r\n-        if (args.interactor == secondInteractor)\r\n-            secondInteractor = null;\r\n     }\r\n \r\n     public override void ProcessInteractable(XRInteractionUpdateOrder.UpdatePhase updatePhase)\r\n     {\r\n-        if (isSelected && secondInteractor != null)\r\n+        if (isSelected)\r\n         {\r\n             if (updatePhase == XRInteractionUpdateOrder.UpdatePhase.Dynamic)\r\n             {\r\n-                // Calculate the position by averaging the position of both interactors\r\n-                Vector3 positionDelta = (selectingInteractor.attachTransform.position + secondInteractor.attachTransform.position) / 2 - transform.position;\r\n-                transform.position += positionDelta;\r\n-\r\n-                // Calculate the rotation by combining the rotations of both interactors\r\n-                Quaternion rotationDelta = selectingInteractor.attachTransform.rotation * Quaternion.Inverse(initialAttachLocalRot);\r\n-                Quaternion secondRotationDelta = secondInteractor.attachTransform.rotation * Quaternion.Inverse(attachRotationDelta);\r\n-                transform.rotation = Quaternion.Lerp(rotationDelta, secondRotationDelta, 0.5f) * transform.rotation;\r\n-\r\n-                // Double the rotation if the feature is enabled\r\n-                if (doubleRotationSpeed)\r\n+                var interactor = interactorsSelecting.FirstOrDefault();  // Assuming you want the first or any interactor\r\n+                if (interactor != null)\r\n                 {\r\n-                    Quaternion additionalRotation = Quaternion.AngleAxis(rotationDelta.eulerAngles.magnitude, rotationDelta.eulerAngles.normalized) * transform.rotation;\r\n-                    transform.rotation = additionalRotation;\r\n+                    // Apply rotation logic or position update\r\n+                    // For example, rotating based on the initial grab rotation\r\n+                    transform.rotation = Quaternion.Euler(initialAttachLocalRot.eulerAngles + (interactor.transform.localRotation.eulerAngles - initialAttachLocalRot.eulerAngles));\r\n                 }\r\n             }\r\n         }\r\n         else\r\n"
                },
                {
                    "date": 1739226730537,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,7 @@\n using UnityEngine;\r\n using UnityEngine.XR.Interaction.Toolkit;\r\n+using System.Linq;  // Add this line\r\n \r\n public class CustomGrab : XRGrabInteractable\r\n {\r\n     private Transform initialAttachLocalPos;\r\n@@ -23,13 +24,12 @@\n         if (isSelected)\r\n         {\r\n             if (updatePhase == XRInteractionUpdateOrder.UpdatePhase.Dynamic)\r\n             {\r\n-                var interactor = interactorsSelecting.FirstOrDefault();  // Assuming you want the first or any interactor\r\n+                var interactor = interactorsSelecting.FirstOrDefault();  // This should now work\r\n                 if (interactor != null)\r\n                 {\r\n                     // Apply rotation logic or position update\r\n-                    // For example, rotating based on the initial grab rotation\r\n                     transform.rotation = Quaternion.Euler(initialAttachLocalRot.eulerAngles + (interactor.transform.localRotation.eulerAngles - initialAttachLocalRot.eulerAngles));\r\n                 }\r\n             }\r\n         }\r\n"
                },
                {
                    "date": 1739228107965,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,41 +1,126 @@\n+using System.Collections;\r\n+using System.Collections.Generic;\r\n using UnityEngine;\r\n-using UnityEngine.XR.Interaction.Toolkit;\r\n-using System.Linq;  // Add this line\r\n+using UnityEngine.InputSystem;\r\n \r\n-public class CustomGrab : XRGrabInteractable\r\n+public class CustomGrab : MonoBehaviour\r\n {\r\n-    private Transform initialAttachLocalPos;\r\n-    private Quaternion initialAttachLocalRot;\r\n+    public List<Transform> nearObjects = new List<Transform>();  // List of potential objects to grab\r\n+    public Transform grabbedObject = null;                       // Currently grabbed object\r\n+    public InputActionReference action;                          // Reference to the action for grabbing\r\n+    public InputActionReference toggleDoubleRotationAction;      // Reference to the action for toggling double rotation\r\n \r\n-    protected override void OnSelectEntered(SelectEnterEventArgs args)\r\n+    private CustomGrab otherHand;                                 // Reference to the other hand's script\r\n+    private bool grabbing = false;                                // Is the grab action being pressed?\r\n+    private Vector3 previousPosition;                             // Previous frame's position\r\n+    private Quaternion previousRotation;                          // Previous frame's rotation\r\n+    private bool doubleRotation = false;                          // Should double rotation be applied?\r\n+\r\n+    void Start()\r\n     {\r\n-        base.OnSelectEntered(args);\r\n-        initialAttachLocalPos = args.interactorObject.transform;\r\n-        initialAttachLocalRot = args.interactorObject.transform.localRotation;\r\n+        action.action.Enable();\r\n+        toggleDoubleRotationAction.action.Enable();\r\n+        toggleDoubleRotationAction.action.performed += ToggleDoubleRotation;\r\n+\r\n+        // Initialize the reference to the other hand's CustomGrab component\r\n+        otherHand = GetComponentInParent<CustomGrab>();\r\n     }\r\n \r\n-    protected override void OnSelectExited(SelectExitEventArgs args)\r\n+    void Update()\r\n     {\r\n-        base.OnSelectExited(args);\r\n+        grabbing = action.action.IsPressed();\r\n+        HandleGrabbing();\r\n+        previousPosition = transform.position;\r\n+        previousRotation = transform.rotation;\r\n     }\r\n \r\n-    public override void ProcessInteractable(XRInteractionUpdateOrder.UpdatePhase updatePhase)\r\n+    private void HandleGrabbing()\r\n     {\r\n-        if (isSelected)\r\n+        if (grabbing)\r\n         {\r\n-            if (updatePhase == XRInteractionUpdateOrder.UpdatePhase.Dynamic)\r\n+            TryGrab();\r\n+            if (grabbedObject)\r\n             {\r\n-                var interactor = interactorsSelecting.FirstOrDefault();  // This should now work\r\n-                if (interactor != null)\r\n-                {\r\n-                    // Apply rotation logic or position update\r\n-                    transform.rotation = Quaternion.Euler(initialAttachLocalRot.eulerAngles + (interactor.transform.localRotation.eulerAngles - initialAttachLocalRot.eulerAngles));\r\n-                }\r\n+                PerformTransformation();\r\n             }\r\n         }\r\n+        else if (grabbedObject)\r\n+        {\r\n+            grabbedObject = null; // Release the object when no longer grabbing\r\n+        }\r\n+    }\r\n+\r\n+    private void TryGrab()\r\n+    {\r\n+        if (!grabbedObject)\r\n+        {\r\n+            grabbedObject = nearObjects.Count > 0 ? nearObjects[0] : otherHand.grabbedObject;\r\n+        }\r\n+    }\r\n+\r\n+    private void PerformTransformation()\r\n+    {\r\n+        if (otherHand.grabbing && otherHand.grabbedObject == grabbedObject)\r\n+        {\r\n+            // Both hands are grabbing the same object\r\n+            Vector3 combinedDeltaPosition = (transform.position - previousPosition + otherHand.transform.position - otherHand.previousPosition) / 2;\r\n+            Quaternion combinedDeltaRotation = Quaternion.Slerp(\r\n+                Quaternion.Inverse(previousRotation) * transform.rotation,\r\n+                Quaternion.Inverse(otherHand.previousRotation) * otherHand.transform.rotation,\r\n+                0.5f\r\n+            );\r\n+\r\n+            if (doubleRotation)\r\n+            {\r\n+                combinedDeltaRotation = DoubleRotationMagnitude(combinedDeltaRotation);\r\n+            }\r\n+\r\n+            ApplyDeltaTransform(grabbedObject, combinedDeltaPosition, combinedDeltaRotation);\r\n+        }\r\n         else\r\n         {\r\n-            base.ProcessInteractable(updatePhase);\r\n+            // Single hand grabbing logic\r\n+            Vector3 deltaPosition = transform.position - previousPosition;\r\n+            Quaternion deltaRotation = Quaternion.Inverse(previousRotation) * transform.rotation;\r\n+\r\n+            if (doubleRotation)\r\n+            {\r\n+                deltaRotation = DoubleRotationMagnitude(deltaRotation);\r\n+            }\r\n+\r\n+            ApplyDeltaTransform(grabbedObject, deltaPosition, deltaRotation);\r\n         }\r\n     }\r\n+\r\n+    private Quaternion DoubleRotationMagnitude(Quaternion rotation)\r\n+    {\r\n+        rotation.ToAngleAxis(out float angle, out Vector3 axis);\r\n+        angle *= 2f;\r\n+        return Quaternion.AngleAxis(angle, axis);\r\n+    }\r\n+\r\n+    private void ApplyDeltaTransform(Transform target, Vector3 deltaPosition, Quaternion deltaRotation)\r\n+    {\r\n+        target.position += deltaPosition;\r\n+        Vector3 offset = target.position - transform.position;\r\n+        target.position = transform.position + (deltaRotation * offset);\r\n+        target.rotation = deltaRotation * target.rotation;\r\n+    }\r\n+\r\n+    private void ToggleDoubleRotation(InputAction.CallbackContext context)\r\n+    {\r\n+        doubleRotation = !doubleRotation;\r\n+    }\r\n+\r\n+    private void OnTriggerEnter(Collider other)\r\n+    {\r\n+        if (other.CompareTag(\"Grabbable\"))\r\n+            nearObjects.Add(other.transform);\r\n+    }\r\n+\r\n+    private void OnTriggerExit(Collider other)\r\n+    {\r\n+        if (other.CompareTag(\"Grabbable\"))\r\n+            nearObjects.Remove(other.transform);\r\n+    }\r\n }\r\n"
                },
                {
                    "date": 1739231421407,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,126 +1,53 @@\n-using System.Collections;\r\n-using System.Collections.Generic;\r\n using UnityEngine;\r\n-using UnityEngine.InputSystem;\r\n \r\n public class CustomGrab : MonoBehaviour\r\n {\r\n-    public List<Transform> nearObjects = new List<Transform>();  // List of potential objects to grab\r\n-    public Transform grabbedObject = null;                       // Currently grabbed object\r\n-    public InputActionReference action;                          // Reference to the action for grabbing\r\n-    public InputActionReference toggleDoubleRotationAction;      // Reference to the action for toggling double rotation\r\n+    public Transform leftHand;\r\n+    public Transform rightHand;\r\n+    public bool isGrabbed = false;\r\n+    private Vector3 initialOffset;\r\n+    private Quaternion initialRotationOffset;\r\n+    public bool enableDoubleRotation = false;\r\n \r\n-    private CustomGrab otherHand;                                 // Reference to the other hand's script\r\n-    private bool grabbing = false;                                // Is the grab action being pressed?\r\n-    private Vector3 previousPosition;                             // Previous frame's position\r\n-    private Quaternion previousRotation;                          // Previous frame's rotation\r\n-    private bool doubleRotation = false;                          // Should double rotation be applied?\r\n-\r\n-    void Start()\r\n-    {\r\n-        action.action.Enable();\r\n-        toggleDoubleRotationAction.action.Enable();\r\n-        toggleDoubleRotationAction.action.performed += ToggleDoubleRotation;\r\n-\r\n-        // Initialize the reference to the other hand's CustomGrab component\r\n-        otherHand = GetComponentInParent<CustomGrab>();\r\n-    }\r\n-\r\n     void Update()\r\n     {\r\n-        grabbing = action.action.IsPressed();\r\n-        HandleGrabbing();\r\n-        previousPosition = transform.position;\r\n-        previousRotation = transform.rotation;\r\n-    }\r\n-\r\n-    private void HandleGrabbing()\r\n-    {\r\n-        if (grabbing)\r\n+        if (isGrabbed)\r\n         {\r\n-            TryGrab();\r\n-            if (grabbedObject)\r\n-            {\r\n-                PerformTransformation();\r\n-            }\r\n-        }\r\n-        else if (grabbedObject)\r\n-        {\r\n-            grabbedObject = null; // Release the object when no longer grabbing\r\n-        }\r\n-    }\r\n+            Vector3 leftHandPosition = leftHand.position;\r\n+            Vector3 rightHandPosition = rightHand.position;\r\n+            Vector3 midpoint = (leftHandPosition + rightHandPosition) / 2;\r\n \r\n-    private void TryGrab()\r\n-    {\r\n-        if (!grabbedObject)\r\n-        {\r\n-            grabbedObject = nearObjects.Count > 0 ? nearObjects[0] : otherHand.grabbedObject;\r\n-        }\r\n-    }\r\n+            // Calculate the rotation by looking at the direction from the right hand to the left hand\r\n+            Quaternion targetRotation = Quaternion.LookRotation(leftHandPosition - rightHandPosition);\r\n+            Quaternion rotationDelta = targetRotation * Quaternion.Inverse(initialRotationOffset);\r\n \r\n-    private void PerformTransformation()\r\n-    {\r\n-        if (otherHand.grabbing && otherHand.grabbedObject == grabbedObject)\r\n-        {\r\n-            // Both hands are grabbing the same object\r\n-            Vector3 combinedDeltaPosition = (transform.position - previousPosition + otherHand.transform.position - otherHand.previousPosition) / 2;\r\n-            Quaternion combinedDeltaRotation = Quaternion.Slerp(\r\n-                Quaternion.Inverse(previousRotation) * transform.rotation,\r\n-                Quaternion.Inverse(otherHand.previousRotation) * otherHand.transform.rotation,\r\n-                0.5f\r\n-            );\r\n-\r\n-            if (doubleRotation)\r\n+            // Double the rotation if enabled\r\n+            if (enableDoubleRotation)\r\n             {\r\n-                combinedDeltaRotation = DoubleRotationMagnitude(combinedDeltaRotation);\r\n+                rotationDelta *= 2;\r\n             }\r\n \r\n-            ApplyDeltaTransform(grabbedObject, combinedDeltaPosition, combinedDeltaRotation);\r\n+            // Apply translation and rotation\r\n+            transform.position = midpoint + rotationDelta * initialOffset;\r\n+            transform.rotation = rotationDelta * transform.rotation;\r\n         }\r\n-        else\r\n+\r\n+        // Check for input to toggle double rotation\r\n+        if (Input.GetKeyDown(KeyCode.T)) // Placeholder key for toggling double rotation\r\n         {\r\n-            // Single hand grabbing logic\r\n-            Vector3 deltaPosition = transform.position - previousPosition;\r\n-            Quaternion deltaRotation = Quaternion.Inverse(previousRotation) * transform.rotation;\r\n-\r\n-            if (doubleRotation)\r\n-            {\r\n-                deltaRotation = DoubleRotationMagnitude(deltaRotation);\r\n-            }\r\n-\r\n-            ApplyDeltaTransform(grabbedObject, deltaPosition, deltaRotation);\r\n+            enableDoubleRotation = !enableDoubleRotation;\r\n         }\r\n     }\r\n \r\n-    private Quaternion DoubleRotationMagnitude(Quaternion rotation)\r\n+    public void Grab()\r\n     {\r\n-        rotation.ToAngleAxis(out float angle, out Vector3 axis);\r\n-        angle *= 2f;\r\n-        return Quaternion.AngleAxis(angle, axis);\r\n+        isGrabbed = true;\r\n+        initialOffset = transform.position - (leftHand.position + rightHand.position) / 2;\r\n+        initialRotationOffset = Quaternion.LookRotation(leftHand.position - rightHand.position);\r\n     }\r\n \r\n-    private void ApplyDeltaTransform(Transform target, Vector3 deltaPosition, Quaternion deltaRotation)\r\n+    public void Release()\r\n     {\r\n-        target.position += deltaPosition;\r\n-        Vector3 offset = target.position - transform.position;\r\n-        target.position = transform.position + (deltaRotation * offset);\r\n-        target.rotation = deltaRotation * target.rotation;\r\n+        isGrabbed = false;\r\n     }\r\n-\r\n-    private void ToggleDoubleRotation(InputAction.CallbackContext context)\r\n-    {\r\n-        doubleRotation = !doubleRotation;\r\n-    }\r\n-\r\n-    private void OnTriggerEnter(Collider other)\r\n-    {\r\n-        if (other.CompareTag(\"Grabbable\"))\r\n-            nearObjects.Add(other.transform);\r\n-    }\r\n-\r\n-    private void OnTriggerExit(Collider other)\r\n-    {\r\n-        if (other.CompareTag(\"Grabbable\"))\r\n-            nearObjects.Remove(other.transform);\r\n-    }\r\n }\r\n"
                },
                {
                    "date": 1739231579395,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,53 +1,65 @@\n using UnityEngine;\r\n+using UnityEngine.XR.Interaction.Toolkit;\r\n \r\n-public class CustomGrab : MonoBehaviour\r\n+public class TwoHandedGrabInteractable : XRGrabInteractable\r\n {\r\n-    public Transform leftHand;\r\n-    public Transform rightHand;\r\n-    public bool isGrabbed = false;\r\n-    private Vector3 initialOffset;\r\n-    private Quaternion initialRotationOffset;\r\n-    public bool enableDoubleRotation = false;\r\n+    private XRBaseInteractor secondInteractor;\r\n+    private Quaternion attachInitialRotation;\r\n+    private Vector3 initialAttachPositionDifference;\r\n \r\n-    void Update()\r\n+    public bool enableDoubleRotation = false; // Toggle for doubling the rotation applied to the object\r\n+\r\n+    protected override void OnSelectEntered(SelectEnterEventArgs args)\r\n     {\r\n-        if (isGrabbed)\r\n+        base.OnSelectEntered(args);\r\n+        if (secondInteractor == null)\r\n         {\r\n-            Vector3 leftHandPosition = leftHand.position;\r\n-            Vector3 rightHandPosition = rightHand.position;\r\n-            Vector3 midpoint = (leftHandPosition + rightHandPosition) / 2;\r\n+            // Save the initial rotation and position relative to the first interactor\r\n+            attachInitialRotation = args.interactor.attachTransform.localRotation;\r\n+            initialAttachPositionDifference = transform.position - args.interactor.attachTransform.position;\r\n+        }\r\n+        else\r\n+        {\r\n+            // Calculate the difference in rotation from the first and second interactor's attach points\r\n+            attachInitialRotation = Quaternion.Inverse(args.interactor.attachTransform.localRotation) * attachInitialRotation;\r\n+        }\r\n+        secondInteractor = args.interactor; // This assumes the second hand has now grabbed the object\r\n+    }\r\n \r\n-            // Calculate the rotation by looking at the direction from the right hand to the left hand\r\n-            Quaternion targetRotation = Quaternion.LookRotation(leftHandPosition - rightHandPosition);\r\n-            Quaternion rotationDelta = targetRotation * Quaternion.Inverse(initialRotationOffset);\r\n+    protected override void OnSelectExited(SelectExitEventArgs args)\r\n+    {\r\n+        base.OnSelectExited(args);\r\n+        if (secondInteractor == args.interactor)\r\n+        {\r\n+            secondInteractor = null;\r\n+        }\r\n+    }\r\n \r\n-            // Double the rotation if enabled\r\n+    public override void ProcessInteractable(XRInteractionUpdateOrder.UpdatePhase updatePhase)\r\n+    {\r\n+        base.ProcessInteractable(updatePhase);\r\n+        if (isSelected && secondInteractor != null)\r\n+        {\r\n+            // Calculate the midpoint between two interactors\r\n+            Vector3 midpoint = (selectingInteractor.attachTransform.position + secondInteractor.attachTransform.position) / 2;\r\n+\r\n+            // Apply the rotation considering the initial rotation offset\r\n+            Quaternion rotationDelta = Quaternion.Slerp(selectingInteractor.attachTransform.rotation, secondInteractor.attachTransform.rotation, 0.5f) * attachInitialRotation;\r\n+\r\n             if (enableDoubleRotation)\r\n             {\r\n-                rotationDelta *= 2;\r\n+                rotationDelta *= 2; // Double the rotation magnitude\r\n             }\r\n \r\n-            // Apply translation and rotation\r\n-            transform.position = midpoint + rotationDelta * initialOffset;\r\n-            transform.rotation = rotationDelta * transform.rotation;\r\n+            // Apply translation and rotation to the object\r\n+            transform.position = midpoint + rotationDelta * initialAttachPositionDifference;\r\n+            transform.rotation = rotationDelta;\r\n         }\r\n-\r\n-        // Check for input to toggle double rotation\r\n-        if (Input.GetKeyDown(KeyCode.T)) // Placeholder key for toggling double rotation\r\n-        {\r\n-            enableDoubleRotation = !enableDoubleRotation;\r\n-        }\r\n     }\r\n \r\n-    public void Grab()\r\n+    // Function to toggle the double rotation feature\r\n+    public void ToggleDoubleRotation()\r\n     {\r\n-        isGrabbed = true;\r\n-        initialOffset = transform.position - (leftHand.position + rightHand.position) / 2;\r\n-        initialRotationOffset = Quaternion.LookRotation(leftHand.position - rightHand.position);\r\n+        enableDoubleRotation = !enableDoubleRotation;\r\n     }\r\n-\r\n-    public void Release()\r\n-    {\r\n-        isGrabbed = false;\r\n-    }\r\n }\r\n"
                },
                {
                    "date": 1739231680425,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,65 +1,125 @@\n+using System.Collections;\r\n+using System.Collections.Generic;\r\n using UnityEngine;\r\n-using UnityEngine.XR.Interaction.Toolkit;\r\n+using UnityEngine.InputSystem;\r\n \r\n-public class TwoHandedGrabInteractable : XRGrabInteractable\r\n+public class CustomGrab : MonoBehaviour\r\n {\r\n-    private XRBaseInteractor secondInteractor;\r\n-    private Quaternion attachInitialRotation;\r\n-    private Vector3 initialAttachPositionDifference;\r\n+    // This script should be attached to both controller objects in the scene\r\n+    // Make sure to define the input in the editor (LeftHand/Grip and RightHand/Grip recommended respectively)\r\n+    CustomGrab otherHand = null;\r\n+    public List<Transform> nearObjects = new List<Transform>();\r\n+    public Transform grabbedObject = null;\r\n+    public InputActionReference action;\r\n+    public InputActionReference toggleDoubleRotationAction;\r\n \r\n-    public bool enableDoubleRotation = false; // Toggle for doubling the rotation applied to the object\r\n+    private bool grabbing = false;\r\n+    private Vector3 previousPosition;\r\n+    private Quaternion previousRotation;\r\n+    private bool doubleRotation = false;\r\n \r\n-    protected override void OnSelectEntered(SelectEnterEventArgs args)\r\n+    private void Start()\r\n     {\r\n-        base.OnSelectEntered(args);\r\n-        if (secondInteractor == null)\r\n+        action.action.Enable();\r\n+        toggleDoubleRotationAction.action.Enable();\r\n+\r\n+        toggleDoubleRotationAction.action.performed += ToggleDoubleRotation;\r\n+\r\n+        // Find the other hand\r\n+        foreach (CustomGrab c in transform.parent.GetComponentsInChildren<CustomGrab>())\r\n         {\r\n-            // Save the initial rotation and position relative to the first interactor\r\n-            attachInitialRotation = args.interactor.attachTransform.localRotation;\r\n-            initialAttachPositionDifference = transform.position - args.interactor.attachTransform.position;\r\n+            if (c != this)\r\n+                otherHand = c;\r\n         }\r\n-        else\r\n-        {\r\n-            // Calculate the difference in rotation from the first and second interactor's attach points\r\n-            attachInitialRotation = Quaternion.Inverse(args.interactor.attachTransform.localRotation) * attachInitialRotation;\r\n-        }\r\n-        secondInteractor = args.interactor; // This assumes the second hand has now grabbed the object\r\n+\r\n+        previousPosition = transform.position;\r\n+        previousRotation = transform.rotation;\r\n     }\r\n \r\n-    protected override void OnSelectExited(SelectExitEventArgs args)\r\n+    void Update()\r\n     {\r\n-        base.OnSelectExited(args);\r\n-        if (secondInteractor == args.interactor)\r\n+        grabbing = action.action.IsPressed();\r\n+\r\n+        if (grabbing)\r\n         {\r\n-            secondInteractor = null;\r\n+            if (!grabbedObject)\r\n+                grabbedObject = nearObjects.Count > 0 ? nearObjects[0] : otherHand.grabbedObject;\r\n+\r\n+            if (grabbedObject)\r\n+            {\r\n+                if (otherHand.grabbing && otherHand.grabbedObject == grabbedObject)\r\n+                {\r\n+                    Vector3 combinedDeltaPosition = (transform.position - previousPosition + otherHand.transform.position - otherHand.previousPosition) / 2;\r\n+                    Quaternion combinedDeltaRotation = Quaternion.Slerp(\r\n+                        transform.rotation * Quaternion.Inverse(previousRotation),\r\n+                        otherHand.transform.rotation * Quaternion.Inverse(otherHand.previousRotation),\r\n+                        0.5f\r\n+                    );\r\n+\r\n+                    if (doubleRotation)\r\n+                        combinedDeltaRotation = DoubleRotationMagnitude(combinedDeltaRotation);\r\n+\r\n+                    ApplyDeltaTransform(grabbedObject, combinedDeltaPosition, combinedDeltaRotation);\r\n+                }\r\n+                else\r\n+                {\r\n+                    Vector3 deltaPosition = transform.position - previousPosition;\r\n+                    Quaternion deltaRotation = transform.rotation * Quaternion.Inverse(previousRotation);\r\n+\r\n+                    if (doubleRotation)\r\n+                        deltaRotation = DoubleRotationMagnitude(deltaRotation);\r\n+\r\n+                    ApplyDeltaTransform(grabbedObject, deltaPosition, deltaRotation);\r\n+                }\r\n+            }\r\n         }\r\n+        // If let go of button, release object\r\n+        else if (grabbedObject)\r\n+        {\r\n+            grabbedObject = null;\r\n+        }\r\n+        previousPosition = transform.position;\r\n+        previousRotation = transform.rotation;\r\n     }\r\n \r\n-    public override void ProcessInteractable(XRInteractionUpdateOrder.UpdatePhase updatePhase)\r\n+    private void ToggleDoubleRotation(InputAction.CallbackContext context)\r\n     {\r\n-        base.ProcessInteractable(updatePhase);\r\n-        if (isSelected && secondInteractor != null)\r\n-        {\r\n-            // Calculate the midpoint between two interactors\r\n-            Vector3 midpoint = (selectingInteractor.attachTransform.position + secondInteractor.attachTransform.position) / 2;\r\n+        doubleRotation = !doubleRotation;\r\n+    }\r\n \r\n-            // Apply the rotation considering the initial rotation offset\r\n-            Quaternion rotationDelta = Quaternion.Slerp(selectingInteractor.attachTransform.rotation, secondInteractor.attachTransform.rotation, 0.5f) * attachInitialRotation;\r\n+    private Quaternion DoubleRotationMagnitude(Quaternion rotation)\r\n+    {\r\n+        rotation.ToAngleAxis(out float angle, out Vector3 axis);\r\n+        angle *= 2f;\r\n+        return Quaternion.AngleAxis(angle, axis);\r\n+    }\r\n \r\n-            if (enableDoubleRotation)\r\n-            {\r\n-                rotationDelta *= 2; // Double the rotation magnitude\r\n-            }\r\n+    private void ApplyDeltaTransform(Transform target, Vector3 deltaPosition, Quaternion deltaRotation)\r\n+    {\r\n+        target.position += deltaPosition;\r\n+        Vector3 offset = target.position - transform.position;\r\n+        offset = deltaRotation * offset;\r\n+        target.position = transform.position + offset;\r\n+        target.rotation = deltaRotation * target.rotation;\r\n+    }\r\n \r\n-            // Apply translation and rotation to the object\r\n-            transform.position = midpoint + rotationDelta * initialAttachPositionDifference;\r\n-            transform.rotation = rotationDelta;\r\n-        }\r\n+    private void OnTriggerEnter(Collider other)\r\n+    {\r\n+        // Make sure to tag grabbable objects with the \"grabbable\" tag\r\n+        // You also need to make sure to have colliders for the grabbable objects and the controllers\r\n+        // Make sure to set the controller colliders as triggers or they will get misplaced\r\n+        // You also need to add Rigidbody to the controllers for these functions to be triggered\r\n+        // Make sure gravity is disabled though, or your controllers will (virtually) fall to the ground\r\n+        \r\n+        Transform t = other.transform;\r\n+        if (t && t.tag.ToLower() == \"grabbable\")\r\n+            nearObjects.Add(t);\r\n     }\r\n \r\n-    // Function to toggle the double rotation feature\r\n-    public void ToggleDoubleRotation()\r\n+    private void OnTriggerExit(Collider other)\r\n     {\r\n-        enableDoubleRotation = !enableDoubleRotation;\r\n+        Transform t = other.transform;\r\n+        if (t && t.tag.ToLower() == \"grabbable\")\r\n+            nearObjects.Remove(t);\r\n     }\r\n }\r\n"
                },
                {
                    "date": 1739232427294,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,26 +17,44 @@\n     private Vector3 previousPosition;\r\n     private Quaternion previousRotation;\r\n     private bool doubleRotation = false;\r\n \r\n-    private void Start()\r\n+private void Start()\r\n+{\r\n+    if (action == null || toggleDoubleRotationAction == null)\r\n     {\r\n-        action.action.Enable();\r\n-        toggleDoubleRotationAction.action.Enable();\r\n+        Debug.LogError(\"InputActionReferences are not set on \" + gameObject.name);\r\n+        return; // Stop further execution of this method\r\n+    }\r\n \r\n-        toggleDoubleRotationAction.action.performed += ToggleDoubleRotation;\r\n+    action.action.Enable();\r\n+    toggleDoubleRotationAction.action.Enable();\r\n \r\n-        // Find the other hand\r\n+    toggleDoubleRotationAction.action.performed += ToggleDoubleRotation;\r\n+\r\n+    // Find the other hand\r\n+    if (transform.parent != null)\r\n+    {\r\n         foreach (CustomGrab c in transform.parent.GetComponentsInChildren<CustomGrab>())\r\n         {\r\n             if (c != this)\r\n+            {\r\n                 otherHand = c;\r\n+                break;\r\n+            }\r\n         }\r\n-\r\n-        previousPosition = transform.position;\r\n-        previousRotation = transform.rotation;\r\n     }\r\n+    \r\n+    if (otherHand == null)\r\n+    {\r\n+        Debug.LogError(\"Other hand was not found on \" + gameObject.name);\r\n+    }\r\n \r\n+    previousPosition = transform.position;\r\n+    previousRotation = transform.rotation;\r\n+}\r\n+\r\n+\r\n     void Update()\r\n     {\r\n         grabbing = action.action.IsPressed();\r\n \r\n"
                },
                {
                    "date": 1739232435609,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,44 +17,43 @@\n     private Vector3 previousPosition;\r\n     private Quaternion previousRotation;\r\n     private bool doubleRotation = false;\r\n \r\n-private void Start()\r\n-{\r\n-    if (action == null || toggleDoubleRotationAction == null)\r\n-    {\r\n-        Debug.LogError(\"InputActionReferences are not set on \" + gameObject.name);\r\n-        return; // Stop further execution of this method\r\n-    }\r\n+    private void Start() {\r\n+        if (action == null || toggleDoubleRotationAction == null)\r\n+        {\r\n+            Debug.LogError(\"InputActionReferences are not set on \" + gameObject.name);\r\n+            return; // Stop further execution of this method\r\n+        }\r\n \r\n-    action.action.Enable();\r\n-    toggleDoubleRotationAction.action.Enable();\r\n+        action.action.Enable();\r\n+        toggleDoubleRotationAction.action.Enable();\r\n \r\n-    toggleDoubleRotationAction.action.performed += ToggleDoubleRotation;\r\n+        toggleDoubleRotationAction.action.performed += ToggleDoubleRotation;\r\n \r\n-    // Find the other hand\r\n-    if (transform.parent != null)\r\n-    {\r\n-        foreach (CustomGrab c in transform.parent.GetComponentsInChildren<CustomGrab>())\r\n+        // Find the other hand\r\n+        if (transform.parent != null)\r\n         {\r\n-            if (c != this)\r\n+            foreach (CustomGrab c in transform.parent.GetComponentsInChildren<CustomGrab>())\r\n             {\r\n-                otherHand = c;\r\n-                break;\r\n+                if (c != this)\r\n+                {\r\n+                    otherHand = c;\r\n+                    break;\r\n+                }\r\n             }\r\n         }\r\n+        \r\n+        if (otherHand == null)\r\n+        {\r\n+            Debug.LogError(\"Other hand was not found on \" + gameObject.name);\r\n+        }\r\n+\r\n+        previousPosition = transform.position;\r\n+        previousRotation = transform.rotation;\r\n     }\r\n-    \r\n-    if (otherHand == null)\r\n-    {\r\n-        Debug.LogError(\"Other hand was not found on \" + gameObject.name);\r\n-    }\r\n \r\n-    previousPosition = transform.position;\r\n-    previousRotation = transform.rotation;\r\n-}\r\n \r\n-\r\n     void Update()\r\n     {\r\n         grabbing = action.action.IsPressed();\r\n \r\n"
                },
                {
                    "date": 1739232465558,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,140 @@\n+using System.Collections;\r\n+using System.Collections.Generic;\r\n+using UnityEngine;\r\n+using UnityEngine.InputSystem;\r\n+\r\n+public class CustomGrab : MonoBehaviour\r\n+{\r\n+    // This script should be attached to both controller objects in the scene\r\n+    // Make sure to define the input in the editor (LeftHand/Grip and RightHand/Grip recommended respectively)\r\n+    CustomGrab otherHand = null;\r\n+    public List<Transform> nearObjects = new List<Transform>();\r\n+    public Transform grabbedObject = null;\r\n+    public InputActionReference action;\r\n+    public InputActionReference toggleDoubleRotationAction;\r\n+\r\n+    private bool grabbing = false;\r\n+    private Vector3 previousPosition;\r\n+    private Quaternion previousRotation;\r\n+    private bool doubleRotation = false;\r\n+\r\n+    private void Start() {\r\n+        if (action == null || toggleDoubleRotationAction == null)\r\n+        {\r\n+            Debug.LogError(\"InputActionReferences are not set on \" + gameObject.name);\r\n+            return; // Stop further execution of this method\r\n+        }\r\n+\r\n+        action.action.Enable();\r\n+        toggleDoubleRotationAction.action.Enable();\r\n+\r\n+        toggleDoubleRotationAction.action.performed += ToggleDoubleRotation;\r\n+\r\n+        // Find the other hand\r\n+        if (transform.parent != null)\r\n+        {\r\n+            foreach (CustomGrab c in transform.parent.GetComponentsInChildren<CustomGrab>())\r\n+            {\r\n+                if (c != this)\r\n+                {\r\n+                    otherHand = c;\r\n+                    break;\r\n+                }\r\n+            }\r\n+        }\r\n+        \r\n+        if (otherHand == null)\r\n+        {\r\n+            Debug.LogError(\"Other hand was not found on \" + gameObject.name);\r\n+        }\r\n+\r\n+        previousPosition = transform.position;\r\n+        previousRotation = transform.rotation;\r\n+    }\r\n+\r\n+\r\n+    void Update() {\r\n+        grabbing = action.action.IsPressed();\r\n+\r\n+        if (grabbing)\r\n+        {\r\n+            if (!grabbedObject)\r\n+                grabbedObject = nearObjects.Count > 0 ? nearObjects[0] : otherHand.grabbedObject;\r\n+\r\n+            if (grabbedObject) {\r\n+                if (otherHand.grabbing && otherHand.grabbedObject == grabbedObject)\r\n+                {\r\n+                    Vector3 combinedDeltaPosition = (transform.position - previousPosition + otherHand.transform.position - otherHand.previousPosition) / 2;\r\n+                    Quaternion combinedDeltaRotation = Quaternion.Slerp(\r\n+                        transform.rotation * Quaternion.Inverse(previousRotation),\r\n+                        otherHand.transform.rotation * Quaternion.Inverse(otherHand.previousRotation),\r\n+                        0.5f\r\n+                    );\r\n+\r\n+                    if (doubleRotation)\r\n+                        combinedDeltaRotation = DoubleRotationMagnitude(combinedDeltaRotation);\r\n+\r\n+                    ApplyDeltaTransform(grabbedObject, combinedDeltaPosition, combinedDeltaRotation);\r\n+                }\r\n+                else\r\n+                {\r\n+                    Vector3 deltaPosition = transform.position - previousPosition;\r\n+                    Quaternion deltaRotation = transform.rotation * Quaternion.Inverse(previousRotation);\r\n+\r\n+                    if (doubleRotation)\r\n+                        deltaRotation = DoubleRotationMagnitude(deltaRotation);\r\n+\r\n+                    ApplyDeltaTransform(grabbedObject, deltaPosition, deltaRotation);\r\n+                }\r\n+            }\r\n+        }\r\n+        // If let go of button, release object\r\n+        else if (grabbedObject)\r\n+        {\r\n+            grabbedObject = null;\r\n+        }\r\n+        previousPosition = transform.position;\r\n+        previousRotation = transform.rotation;\r\n+    }\r\n+\r\n+    private void ToggleDoubleRotation(InputAction.CallbackContext context)\r\n+    {\r\n+        doubleRotation = !doubleRotation;\r\n+    }\r\n+\r\n+    private Quaternion DoubleRotationMagnitude(Quaternion rotation)\r\n+    {\r\n+        rotation.ToAngleAxis(out float angle, out Vector3 axis);\r\n+        angle *= 2f;\r\n+        return Quaternion.AngleAxis(angle, axis);\r\n+    }\r\n+\r\n+    private void ApplyDeltaTransform(Transform target, Vector3 deltaPosition, Quaternion deltaRotation)\r\n+    {\r\n+        target.position += deltaPosition;\r\n+        Vector3 offset = target.position - transform.position;\r\n+        offset = deltaRotation * offset;\r\n+        target.position = transform.position + offset;\r\n+        target.rotation = deltaRotation * target.rotation;\r\n+    }\r\n+\r\n+    private void OnTriggerEnter(Collider other)\r\n+    {\r\n+        // Make sure to tag grabbable objects with the \"grabbable\" tag\r\n+        // You also need to make sure to have colliders for the grabbable objects and the controllers\r\n+        // Make sure to set the controller colliders as triggers or they will get misplaced\r\n+        // You also need to add Rigidbody to the controllers for these functions to be triggered\r\n+        // Make sure gravity is disabled though, or your controllers will (virtually) fall to the ground\r\n+        \r\n+        Transform t = other.transform;\r\n+        if (t && t.tag.ToLower() == \"grabbable\")\r\n+            nearObjects.Add(t);\r\n+    }\r\n+\r\n+    private void OnTriggerExit(Collider other)\r\n+    {\r\n+        Transform t = other.transform;\r\n+        if (t && t.tag.ToLower() == \"grabbable\")\r\n+            nearObjects.Remove(t);\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1739232543052,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,183 +17,26 @@\n     private Vector3 previousPosition;\r\n     private Quaternion previousRotation;\r\n     private bool doubleRotation = false;\r\n \r\n-    private void Start() {\r\n-        if (action == null || toggleDoubleRotationAction == null)\r\n-        {\r\n-            Debug.LogError(\"InputActionReferences are not set on \" + gameObject.name);\r\n-            return; // Stop further execution of this method\r\n-        }\r\n-\r\n-        action.action.Enable();\r\n-        toggleDoubleRotationAction.action.Enable();\r\n-\r\n-        toggleDoubleRotationAction.action.performed += ToggleDoubleRotation;\r\n-\r\n-        // Find the other hand\r\n-        if (transform.parent != null)\r\n-        {\r\n-            foreach (CustomGrab c in transform.parent.GetComponentsInChildren<CustomGrab>())\r\n-            {\r\n-                if (c != this)\r\n-                {\r\n-                    otherHand = c;\r\n-                    break;\r\n-                }\r\n-            }\r\n-        }\r\n-        \r\n-        if (otherHand == null)\r\n-        {\r\n-            Debug.LogError(\"Other hand was not found on \" + gameObject.name);\r\n-        }\r\n-\r\n-        previousPosition = transform.position;\r\n-        previousRotation = transform.rotation;\r\n-    }\r\n-\r\n-\r\n-    void Update() {\r\n-        grabbing = action.action.IsPressed();\r\n-\r\n-        if (grabbing)\r\n-        {\r\n-            if (!grabbedObject)\r\n-                grabbedObject = nearObjects.Count > 0 ? nearObjects[0] : otherHand.grabbedObject;\r\n-\r\n-            if (grabbedObject) {\r\n-                if (otherHand.grabbing && otherHand.grabbedObject == grabbedObject)\r\n-                {\r\n-                    Vector3 combinedDeltaPosition = (transform.position - previousPosition + otherHand.transform.position - otherHand.previousPosition) / 2;\r\n-                    Quaternion combinedDeltaRotation = Quaternion.Slerp(\r\n-                        transform.rotation * Quaternion.Inverse(previousRotation),\r\n-                        otherHand.transform.rotation * Quaternion.Inverse(otherHand.previousRotation),\r\n-                        0.5f\r\n-                    );\r\n-\r\n-                    if (doubleRotation)\r\n-                        combinedDeltaRotation = DoubleRotationMagnitude(combinedDeltaRotation);\r\n-\r\n-                    ApplyDeltaTransform(grabbedObject, combinedDeltaPosition, combinedDeltaRotation);\r\n-                }\r\n-                else\r\n-                {\r\n-                    Vector3 deltaPosition = transform.position - previousPosition;\r\n-                    Quaternion deltaRotation = transform.rotation * Quaternion.Inverse(previousRotation);\r\n-\r\n-                    if (doubleRotation)\r\n-                        deltaRotation = DoubleRotationMagnitude(deltaRotation);\r\n-\r\n-                    ApplyDeltaTransform(grabbedObject, deltaPosition, deltaRotation);\r\n-                }\r\n-            }\r\n-        }\r\n-        // If let go of button, release object\r\n-        else if (grabbedObject)\r\n-        {\r\n-            grabbedObject = null;\r\n-        }\r\n-        previousPosition = transform.position;\r\n-        previousRotation = transform.rotation;\r\n-    }\r\n-\r\n-    private void ToggleDoubleRotation(InputAction.CallbackContext context)\r\n+    private void Start()\r\n     {\r\n-        doubleRotation = !doubleRotation;\r\n-    }\r\n-\r\n-    private Quaternion DoubleRotationMagnitude(Quaternion rotation)\r\n-    {\r\n-        rotation.ToAngleAxis(out float angle, out Vector3 axis);\r\n-        angle *= 2f;\r\n-        return Quaternion.AngleAxis(angle, axis);\r\n-    }\r\n-\r\n-    private void ApplyDeltaTransform(Transform target, Vector3 deltaPosition, Quaternion deltaRotation)\r\n-    {\r\n-        target.position += deltaPosition;\r\n-        Vector3 offset = target.position - transform.position;\r\n-        offset = deltaRotation * offset;\r\n-        target.position = transform.position + offset;\r\n-        target.rotation = deltaRotation * target.rotation;\r\n-    }\r\n-\r\n-    private void OnTriggerEnter(Collider other)\r\n-    {\r\n-        // Make sure to tag grabbable objects with the \"grabbable\" tag\r\n-        // You also need to make sure to have colliders for the grabbable objects and the controllers\r\n-        // Make sure to set the controller colliders as triggers or they will get misplaced\r\n-        // You also need to add Rigidbody to the controllers for these functions to be triggered\r\n-        // Make sure gravity is disabled though, or your controllers will (virtually) fall to the ground\r\n-        \r\n-        Transform t = other.transform;\r\n-        if (t && t.tag.ToLower() == \"grabbable\")\r\n-            nearObjects.Add(t);\r\n-    }\r\n-\r\n-    private void OnTriggerExit(Collider other)\r\n-    {\r\n-        Transform t = other.transform;\r\n-        if (t && t.tag.ToLower() == \"grabbable\")\r\n-            nearObjects.Remove(t);\r\n-    }\r\n-}\r\n-using System.Collections;\r\n-using System.Collections.Generic;\r\n-using UnityEngine;\r\n-using UnityEngine.InputSystem;\r\n-\r\n-public class CustomGrab : MonoBehaviour\r\n-{\r\n-    // This script should be attached to both controller objects in the scene\r\n-    // Make sure to define the input in the editor (LeftHand/Grip and RightHand/Grip recommended respectively)\r\n-    CustomGrab otherHand = null;\r\n-    public List<Transform> nearObjects = new List<Transform>();\r\n-    public Transform grabbedObject = null;\r\n-    public InputActionReference action;\r\n-    public InputActionReference toggleDoubleRotationAction;\r\n-\r\n-    private bool grabbing = false;\r\n-    private Vector3 previousPosition;\r\n-    private Quaternion previousRotation;\r\n-    private bool doubleRotation = false;\r\n-\r\n-    private void Start() {\r\n-        if (action == null || toggleDoubleRotationAction == null)\r\n-        {\r\n-            Debug.LogError(\"InputActionReferences are not set on \" + gameObject.name);\r\n-            return; // Stop further execution of this method\r\n-        }\r\n-\r\n         action.action.Enable();\r\n         toggleDoubleRotationAction.action.Enable();\r\n \r\n         toggleDoubleRotationAction.action.performed += ToggleDoubleRotation;\r\n \r\n         // Find the other hand\r\n-        if (transform.parent != null)\r\n+        foreach (CustomGrab c in transform.parent.GetComponentsInChildren<CustomGrab>())\r\n         {\r\n-            foreach (CustomGrab c in transform.parent.GetComponentsInChildren<CustomGrab>())\r\n-            {\r\n-                if (c != this)\r\n-                {\r\n-                    otherHand = c;\r\n-                    break;\r\n-                }\r\n-            }\r\n+            if (c != this)\r\n+                otherHand = c;\r\n         }\r\n-        \r\n-        if (otherHand == null)\r\n-        {\r\n-            Debug.LogError(\"Other hand was not found on \" + gameObject.name);\r\n-        }\r\n \r\n         previousPosition = transform.position;\r\n         previousRotation = transform.rotation;\r\n     }\r\n \r\n-\r\n     void Update()\r\n     {\r\n         grabbing = action.action.IsPressed();\r\n \r\n@@ -278,5 +121,5 @@\n         Transform t = other.transform;\r\n         if (t && t.tag.ToLower() == \"grabbable\")\r\n             nearObjects.Remove(t);\r\n     }\r\n-}\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1739278493921,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,125 +1,143 @@\n-using System.Collections;\r\n using System.Collections.Generic;\r\n using UnityEngine;\r\n using UnityEngine.InputSystem;\r\n \r\n-public class CustomGrab : MonoBehaviour\r\n+public class CustomGrabber : MonoBehaviour\r\n {\r\n-    // This script should be attached to both controller objects in the scene\r\n-    // Make sure to define the input in the editor (LeftHand/Grip and RightHand/Grip recommended respectively)\r\n-    CustomGrab otherHand = null;\r\n-    public List<Transform> nearObjects = new List<Transform>();\r\n-    public Transform grabbedObject = null;\r\n-    public InputActionReference action;\r\n-    public InputActionReference toggleDoubleRotationAction;\r\n+    CustomGrabber siblingHand = null;\r\n+    public List<Transform> graspableObjects = new List<Transform>();\r\n+    public Transform heldObject = null;\r\n+    public InputActionReference gripAction;\r\n+    public InputActionReference rotationModeToggle;\r\n \r\n-    private bool grabbing = false;\r\n-    private Vector3 previousPosition;\r\n-    private Quaternion previousRotation;\r\n-    private bool doubleRotation = false;\r\n+    private bool isGrabbing = false;\r\n+    private Vector3 lastPosition;\r\n+    private Quaternion lastRotation;\r\n+    private bool isDoubleRotationEnabled = false;\r\n \r\n-    private void Start()\r\n+    void Start()\r\n     {\r\n-        action.action.Enable();\r\n-        toggleDoubleRotationAction.action.Enable();\r\n+        gripAction.action.Enable();\r\n+        rotationModeToggle.action.Enable();\r\n \r\n-        toggleDoubleRotationAction.action.performed += ToggleDoubleRotation;\r\n+        rotationModeToggle.action.performed += OnToggleRotationMode;\r\n \r\n-        // Find the other hand\r\n-        foreach (CustomGrab c in transform.parent.GetComponentsInChildren<CustomGrab>())\r\n+        // Locate the other hand\r\n+        foreach (CustomGrabber grabber in transform.parent.GetComponentsInChildren<CustomGrabber>())\r\n         {\r\n-            if (c != this)\r\n-                otherHand = c;\r\n+            if (grabber != this)\r\n+                siblingHand = grabber;\r\n         }\r\n \r\n-        previousPosition = transform.position;\r\n-        previousRotation = transform.rotation;\r\n+        lastPosition = transform.position;\r\n+        lastRotation = transform.rotation;\r\n     }\r\n \r\n     void Update()\r\n     {\r\n-        grabbing = action.action.IsPressed();\r\n+        isGrabbing = gripAction.action.IsPressed();\r\n \r\n-        if (grabbing)\r\n+        if (isGrabbing)\r\n         {\r\n-            if (!grabbedObject)\r\n-                grabbedObject = nearObjects.Count > 0 ? nearObjects[0] : otherHand.grabbedObject;\r\n+            TryGrabObject();\r\n \r\n-            if (grabbedObject)\r\n+            if (heldObject)\r\n             {\r\n-                if (otherHand.grabbing && otherHand.grabbedObject == grabbedObject)\r\n+                if (siblingHand.isGrabbing && siblingHand.heldObject == heldObject)\r\n                 {\r\n-                    Vector3 combinedDeltaPosition = (transform.position - previousPosition + otherHand.transform.position - otherHand.previousPosition) / 2;\r\n-                    Quaternion combinedDeltaRotation = Quaternion.Slerp(\r\n-                        transform.rotation * Quaternion.Inverse(previousRotation),\r\n-                        otherHand.transform.rotation * Quaternion.Inverse(otherHand.previousRotation),\r\n-                        0.5f\r\n-                    );\r\n-\r\n-                    if (doubleRotation)\r\n-                        combinedDeltaRotation = DoubleRotationMagnitude(combinedDeltaRotation);\r\n-\r\n-                    ApplyDeltaTransform(grabbedObject, combinedDeltaPosition, combinedDeltaRotation);\r\n+                    HandleSharedObjectManipulation();\r\n                 }\r\n                 else\r\n                 {\r\n-                    Vector3 deltaPosition = transform.position - previousPosition;\r\n-                    Quaternion deltaRotation = transform.rotation * Quaternion.Inverse(previousRotation);\r\n-\r\n-                    if (doubleRotation)\r\n-                        deltaRotation = DoubleRotationMagnitude(deltaRotation);\r\n-\r\n-                    ApplyDeltaTransform(grabbedObject, deltaPosition, deltaRotation);\r\n+                    HandleIndividualObjectManipulation();\r\n                 }\r\n             }\r\n         }\r\n-        // If let go of button, release object\r\n-        else if (grabbedObject)\r\n+        else if (heldObject)\r\n         {\r\n-            grabbedObject = null;\r\n+            ReleaseObject();\r\n         }\r\n-        previousPosition = transform.position;\r\n-        previousRotation = transform.rotation;\r\n+        lastPosition = transform.position;\r\n+        lastRotation = transform.rotation;\r\n     }\r\n \r\n-    private void ToggleDoubleRotation(InputAction.CallbackContext context)\r\n+    private void TryGrabObject()\r\n     {\r\n-        doubleRotation = !doubleRotation;\r\n+        if (!heldObject)\r\n+            heldObject = graspableObjects.Count > 0 ? graspableObjects[0] : siblingHand.heldObject;\r\n     }\r\n \r\n-    private Quaternion DoubleRotationMagnitude(Quaternion rotation)\r\n+    private void HandleSharedObjectManipulation()\r\n\\ No newline at end of file\n     {\r\n+        Vector3 positionChange = AveragePositionChange();\r\n+        Quaternion rotationChange = AverageRotationChange();\r\n+\r\n+        if (isDoubleRotationEnabled)\r\n+            rotationChange = EnhanceRotation(rotationChange);\r\n+\r\n+        MoveAndRotate(heldObject, positionChange, rotationChange);\r\n+    }\r\n+\r\n+    private void HandleIndividualObjectManipulation()\r\n+    {\r\n+        Vector3 positionChange = transform.position - lastPosition;\r\n+        Quaternion rotationChange = transform.rotation * Quaternion.Inverse(lastRotation);\r\n+\r\n+        if (isDoubleRotationEnabled)\r\n+            rotationChange = EnhanceRotation(rotationChange);\r\n+\r\n+        MoveAndRotate(heldObject, positionChange, rotationChange);\r\n+    }\r\n+\r\n+    private void ReleaseObject()\r\n+    {\r\n+        heldObject = null;\r\n+    }\r\n+\r\n+    private Vector3 AveragePositionChange()\r\n+    {\r\n+        return (transform.position - lastPosition + siblingHand.transform.position - siblingHand.lastPosition) / 2;\r\n+    }\r\n+\r\n+    private Quaternion AverageRotationChange()\r\n+    {\r\n+        return Quaternion.Slerp(\r\n+            transform.rotation * Quaternion.Inverse(lastRotation),\r\n+            siblingHand.transform.rotation * Quaternion.Inverse(siblingHand.lastRotation),\r\n+            0.5f\r\n+        );\r\n+    }\r\n+\r\n+    private Quaternion EnhanceRotation(Quaternion rotation)\r\n+    {\r\n         rotation.ToAngleAxis(out float angle, out Vector3 axis);\r\n-        angle *= 2f;\r\n+        angle *= 2; // Double the rotation angle\r\n         return Quaternion.AngleAxis(angle, axis);\r\n     }\r\n \r\n-    private void ApplyDeltaTransform(Transform target, Vector3 deltaPosition, Quaternion deltaRotation)\r\n+    private void MoveAndRotate(Transform target, Vector3 deltaPosition, Quaternion deltaRotation)\r\n     {\r\n         target.position += deltaPosition;\r\n         Vector3 offset = target.position - transform.position;\r\n         offset = deltaRotation * offset;\r\n         target.position = transform.position + offset;\r\n-        target.rotation = deltaRotation * target.rotation;\r\n+        target.rotation *= deltaRotation;\r\n     }\r\n \r\n+    private void OnToggleRotationMode(InputAction.CallbackContext context)\r\n+    {\r\n+        isDoubleRotationEnabled = !isDoubleRotationEnabled;\r\n+    }\r\n+\r\n     private void OnTriggerEnter(Collider other)\r\n     {\r\n-        // Make sure to tag grabbable objects with the \"grabbable\" tag\r\n-        // You also need to make sure to have colliders for the grabbable objects and the controllers\r\n-        // Make sure to set the controller colliders as triggers or they will get misplaced\r\n-        // You also need to add Rigidbody to the controllers for these functions to be triggered\r\n-        // Make sure gravity is disabled though, or your controllers will (virtually) fall to the ground\r\n-        \r\n-        Transform t = other.transform;\r\n-        if (t && t.tag.ToLower() == \"grabbable\")\r\n-            nearObjects.Add(t);\r\n+        if (other.CompareTag(\"Grabbable\"))\r\n+            graspableObjects.Add(other.transform);\r\n     }\r\n \r\n     private void OnTriggerExit(Collider other)\r\n     {\r\n-        Transform t = other.transform;\r\n-        if (t && t.tag.ToLower() == \"grabbable\")\r\n-            nearObjects.Remove(t);\r\n+        if (other.CompareTag(\"Grabbable\"))\r\n+            graspableObjects.Remove(other.transform);\r\n     }\r\n-}\n+}\r\n"
                },
                {
                    "date": 1739286327480,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,143 +1,71 @@\n+using System.Collections;\r\n using System.Collections.Generic;\r\n using UnityEngine;\r\n using UnityEngine.InputSystem;\r\n \r\n-public class CustomGrabber : MonoBehaviour\r\n+public class CustomGrab : MonoBehaviour\r\n {\r\n-    CustomGrabber siblingHand = null;\r\n-    public List<Transform> graspableObjects = new List<Transform>();\r\n-    public Transform heldObject = null;\r\n-    public InputActionReference gripAction;\r\n-    public InputActionReference rotationModeToggle;\r\n+    // This script should be attached to both controller objects in the scene\r\n+    // Make sure to define the input in the editor (LeftHand/Grip and RightHand/Grip recommended respectively)\r\n+    CustomGrab otherHand = null;\r\n+    public List<Transform> nearObjects = new List<Transform>();\r\n+    public Transform grabbedObject = null;\r\n+    public InputActionReference action;\r\n+    bool grabbing = false;\r\n \r\n-    private bool isGrabbing = false;\r\n-    private Vector3 lastPosition;\r\n-    private Quaternion lastRotation;\r\n-    private bool isDoubleRotationEnabled = false;\r\n-\r\n-    void Start()\r\n+    private void Start()\r\n     {\r\n-        gripAction.action.Enable();\r\n-        rotationModeToggle.action.Enable();\r\n+        action.action.Enable();\r\n \r\n-        rotationModeToggle.action.performed += OnToggleRotationMode;\r\n-\r\n-        // Locate the other hand\r\n-        foreach (CustomGrabber grabber in transform.parent.GetComponentsInChildren<CustomGrabber>())\r\n+        // Find the other hand\r\n+        foreach(CustomGrab c in transform.parent.GetComponentsInChildren<CustomGrab>())\r\n         {\r\n-            if (grabber != this)\r\n-                siblingHand = grabber;\r\n+            if (c != this)\r\n+                otherHand = c;\r\n         }\r\n-\r\n-        lastPosition = transform.position;\r\n-        lastRotation = transform.rotation;\r\n     }\r\n \r\n     void Update()\r\n     {\r\n-        isGrabbing = gripAction.action.IsPressed();\r\n-\r\n-        if (isGrabbing)\r\n+        grabbing = action.action.IsPressed();\r\n+        if (grabbing)\r\n         {\r\n-            TryGrabObject();\r\n+            // Grab nearby object or the object in the other hand\r\n+            if (!grabbedObject)\r\n+                grabbedObject = nearObjects.Count > 0 ? nearObjects[0] : otherHand.grabbedObject;\r\n \r\n-            if (heldObject)\r\n+            if (grabbedObject)\r\n             {\r\n-                if (siblingHand.isGrabbing && siblingHand.heldObject == heldObject)\r\n-                {\r\n-                    HandleSharedObjectManipulation();\r\n-                }\r\n-                else\r\n-                {\r\n-                    HandleIndividualObjectManipulation();\r\n-                }\r\n+                // Change these to add the delta position and rotation instead\r\n+                // Save the position and rotation at the end of Update function, so you can compare previous pos/rot to current here\r\n+                grabbedObject.position = transform.position;\r\n+                grabbedObject.rotation = transform.rotation;\r\n             }\r\n         }\r\n-        else if (heldObject)\r\n-        {\r\n-            ReleaseObject();\r\n-        }\r\n-        lastPosition = transform.position;\r\n-        lastRotation = transform.rotation;\r\n-    }\r\n+        // If let go of button, release object\r\n+        else if (grabbedObject)\r\n+            grabbedObject = null;\r\n \r\n-    private void TryGrabObject()\r\n-    {\r\n-        if (!heldObject)\r\n-            heldObject = graspableObjects.Count > 0 ? graspableObjects[0] : siblingHand.heldObject;\r\n+        // Should save the current position and rotation here\r\n     }\r\n \r\n-    private void HandleSharedObjectManipulation()\r\n+    private void OnTriggerEnter(Collider other)\r\n     {\r\n-        Vector3 positionChange = AveragePositionChange();\r\n-        Quaternion rotationChange = AverageRotationChange();\r\n+        // Make sure to tag grabbable objects with the \"grabbable\" tag\r\n+        // You also need to make sure to have colliders for the grabbable objects and the controllers\r\n+        // Make sure to set the controller colliders as triggers or they will get misplaced\r\n+        // You also need to add Rigidbody to the controllers for these functions to be triggered\r\n+        // Make sure gravity is disabled though, or your controllers will (virtually) fall to the ground\r\n \r\n-        if (isDoubleRotationEnabled)\r\n-            rotationChange = EnhanceRotation(rotationChange);\r\n-\r\n-        MoveAndRotate(heldObject, positionChange, rotationChange);\r\n+        Transform t = other.transform;\r\n+        if(t && t.tag.ToLower()==\"grabbable\")\r\n+            nearObjects.Add(t);\r\n     }\r\n \r\n-    private void HandleIndividualObjectManipulation()\r\n-    {\r\n-        Vector3 positionChange = transform.position - lastPosition;\r\n-        Quaternion rotationChange = transform.rotation * Quaternion.Inverse(lastRotation);\r\n-\r\n-        if (isDoubleRotationEnabled)\r\n-            rotationChange = EnhanceRotation(rotationChange);\r\n-\r\n-        MoveAndRotate(heldObject, positionChange, rotationChange);\r\n-    }\r\n-\r\n-    private void ReleaseObject()\r\n-    {\r\n-        heldObject = null;\r\n-    }\r\n-\r\n-    private Vector3 AveragePositionChange()\r\n-    {\r\n-        return (transform.position - lastPosition + siblingHand.transform.position - siblingHand.lastPosition) / 2;\r\n-    }\r\n-\r\n-    private Quaternion AverageRotationChange()\r\n-    {\r\n-        return Quaternion.Slerp(\r\n-            transform.rotation * Quaternion.Inverse(lastRotation),\r\n-            siblingHand.transform.rotation * Quaternion.Inverse(siblingHand.lastRotation),\r\n-            0.5f\r\n-        );\r\n-    }\r\n-\r\n-    private Quaternion EnhanceRotation(Quaternion rotation)\r\n-    {\r\n-        rotation.ToAngleAxis(out float angle, out Vector3 axis);\r\n-        angle *= 2; // Double the rotation angle\r\n-        return Quaternion.AngleAxis(angle, axis);\r\n-    }\r\n-\r\n-    private void MoveAndRotate(Transform target, Vector3 deltaPosition, Quaternion deltaRotation)\r\n-    {\r\n-        target.position += deltaPosition;\r\n-        Vector3 offset = target.position - transform.position;\r\n-        offset = deltaRotation * offset;\r\n-        target.position = transform.position + offset;\r\n-        target.rotation *= deltaRotation;\r\n-    }\r\n-\r\n-    private void OnToggleRotationMode(InputAction.CallbackContext context)\r\n-    {\r\n-        isDoubleRotationEnabled = !isDoubleRotationEnabled;\r\n-    }\r\n-\r\n-    private void OnTriggerEnter(Collider other)\r\n-    {\r\n-        if (other.CompareTag(\"Grabbable\"))\r\n-            graspableObjects.Add(other.transform);\r\n-    }\r\n-\r\n     private void OnTriggerExit(Collider other)\r\n     {\r\n-        if (other.CompareTag(\"Grabbable\"))\r\n-            graspableObjects.Remove(other.transform);\r\n+        Transform t = other.transform;\r\n+        if( t && t.tag.ToLower()==\"grabbable\")\r\n+            nearObjects.Remove(t);\r\n     }\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1739287127991,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,8 +11,12 @@\n     public List<Transform> nearObjects = new List<Transform>();\r\n     public Transform grabbedObject = null;\r\n     public InputActionReference action;\r\n     bool grabbing = false;\r\n+    Vector3 lastPosition;\r\n+    Quaternion lastRotation;\r\n+    bool doubleRotation = false;\r\n+    \r\n \r\n     private void Start()\r\n     {\r\n         action.action.Enable();\r\n@@ -22,8 +26,11 @@\n         {\r\n             if (c != this)\r\n                 otherHand = c;\r\n         }\r\n+        \r\n+        lastPosition = transform.position;\r\n+        lastRotation = transform.rotation;\r\n     }\r\n \r\n     void Update()\r\n     {\r\n@@ -35,21 +42,48 @@\n                 grabbedObject = nearObjects.Count > 0 ? nearObjects[0] : otherHand.grabbedObject;\r\n \r\n             if (grabbedObject)\r\n             {\r\n-                // Change these to add the delta position and rotation instead\r\n-                // Save the position and rotation at the end of Update function, so you can compare previous pos/rot to current here\r\n+                Vector3 currentPosition = transform.position;\r\n+                Quaternion currentRotation = transform.rotation;\r\n+                Vector3 deltaPosition = currentPosition - lastPosition;\r\n+                Quaternion deltaRotation = currentRotation * Quaternion.Inverse(lastRotation);\r\n                 grabbedObject.position = transform.position;\r\n                 grabbedObject.rotation = transform.rotation;\r\n+\r\n+                if (doubleRotation)\r\n+                {\r\n+                    deltaRotation = AmplifyRotation(deltaRotation);\r\n+                }\r\n             }\r\n         }\r\n         // If let go of button, release object\r\n         else if (grabbedObject)\r\n             grabbedObject = null;\r\n \r\n-        // Should save the current position and rotation here\r\n+        // Save the current position and rotation here\r\n+        lastPosition = transform.position;\r\n+        lastRotation = transform.rotation;\r\n     }\r\n+    private Quaternion AmplifyRotation(Quaternion rotation)\r\n+    {\r\n+        rotation.ToAngleAxis(out float angle, out Vector3 axis);\r\n+        angle *= 2;  // Double the rotation angle\r\n+        return Quaternion.AngleAxis(angle, axis);\r\n+    }\r\n \r\n+    private void ApplyTransformations(Transform obj, Vector3 deltaPosition, Quaternion deltaRotation)\r\n+    {\r\n+        obj.position += deltaPosition;  // Move object by delta position\r\n+\r\n+        // Rotate object around its current position\r\n+        Vector3 toObject = obj.position - transform.position;\r\n+        toObject = deltaRotation * toObject;\r\n+        obj.position = transform.position + toObject;\r\n+\r\n+        // Rotate object by delta rotation\r\n+        obj.rotation = deltaRotation * obj.rotation;\r\n+    }\r\n     private void OnTriggerEnter(Collider other)\r\n     {\r\n         // Make sure to tag grabbable objects with the \"grabbable\" tag\r\n         // You also need to make sure to have colliders for the grabbable objects and the controllers\r\n"
                },
                {
                    "date": 1739287171299,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,8 +53,10 @@\n                 if (doubleRotation)\r\n                 {\r\n                     deltaRotation = AmplifyRotation(deltaRotation);\r\n                 }\r\n+                \r\n+                ApplyTransformations(grabbedObject, deltaPosition, deltaRotation);\r\n             }\r\n         }\r\n         // If let go of button, release object\r\n         else if (grabbedObject)\r\n"
                },
                {
                    "date": 1739290122568,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,17 +46,24 @@\n                 Vector3 currentPosition = transform.position;\r\n                 Quaternion currentRotation = transform.rotation;\r\n                 Vector3 deltaPosition = currentPosition - lastPosition;\r\n                 Quaternion deltaRotation = currentRotation * Quaternion.Inverse(lastRotation);\r\n-                grabbedObject.position = transform.position;\r\n-                grabbedObject.rotation = transform.rotation;\r\n \r\n-                if (doubleRotation)\r\n+                // When grabbed by one hand\r\n+                if (!otherHand.grabbing || otherHand.grabbedObject != grabbedObject)\r\n                 {\r\n-                    deltaRotation = AmplifyRotation(deltaRotation);\r\n+                    grabbedObject.position += deltaPosition;\r\n+                    RotateAroundController(deltaRotation);\r\n                 }\r\n-                \r\n-                ApplyTransformations(grabbedObject, deltaPosition, deltaRotation);\r\n+                else // When grabbed by both hands\r\n+                {\r\n+                    // Combine transformations from both hands\r\n+                    Vector3 combinedDeltaPosition = deltaPosition + otherHand.CalculateDeltaPosition();\r\n+                    Quaternion combinedDeltaRotation = deltaRotation * otherHand.CalculateDeltaRotation();\r\n+\r\n+                    grabbedObject.position += combinedDeltaPosition;\r\n+                    RotateAroundController(combinedDeltaRotation);\r\n+                }\r\n             }\r\n         }\r\n         // If let go of button, release object\r\n         else if (grabbedObject)\r\n@@ -65,8 +72,29 @@\n         // Save the current position and rotation here\r\n         lastPosition = transform.position;\r\n         lastRotation = transform.rotation;\r\n     }\r\n+\r\n+        private Quaternion CalculateDeltaRotation()\r\n+    {\r\n+        Quaternion currentRotation = transform.rotation;\r\n+        return currentRotation * Quaternion.Inverse(lastRotation);\r\n+    }\r\n+\r\n+    private Vector3 CalculateDeltaPosition()\r\n+    {\r\n+        Vector3 currentPosition = transform.position;\r\n+        return currentPosition - lastPosition;\r\n+    }\r\n+\r\n+    private void RotateAroundController(Quaternion deltaRotation)\r\n+    {\r\n+        Vector3 toObject = grabbedObject.position - transform.position;\r\n+        toObject = deltaRotation * toObject;\r\n+        grabbedObject.position = transform.position + toObject;\r\n+        grabbedObject.rotation = deltaRotation * grabbedObject.rotation;\r\n+    }\r\n+\r\n     private Quaternion AmplifyRotation(Quaternion rotation)\r\n     {\r\n         rotation.ToAngleAxis(out float angle, out Vector3 axis);\r\n         angle *= 2;  // Double the rotation angle\r\n"
                },
                {
                    "date": 1739324111913,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,8 +15,9 @@\n     Vector3 lastPosition;\r\n     Quaternion lastRotation;\r\n     bool doubleRotation = false;\r\n     \r\n+    \r\n \r\n     private void Start()\r\n     {\r\n         action.action.Enable();\r\n@@ -42,8 +43,10 @@\n                 grabbedObject = nearObjects.Count > 0 ? nearObjects[0] : otherHand.grabbedObject;\r\n \r\n             if (grabbedObject)\r\n             {\r\n+                Rigidbody rb = grabbedObject.GetComponent<Rigidbody>();\r\n+                rb.isKinematic = true;\r\n                 Vector3 currentPosition = transform.position;\r\n                 Quaternion currentRotation = transform.rotation;\r\n                 Vector3 deltaPosition = currentPosition - lastPosition;\r\n                 Quaternion deltaRotation = currentRotation * Quaternion.Inverse(lastRotation);\r\n"
                },
                {
                    "date": 1739324128512,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -70,8 +70,9 @@\n         }\r\n         // If let go of button, release object\r\n         else if (grabbedObject)\r\n             grabbedObject = null;\r\n+            rb.isKinematic = false;\r\n \r\n         // Save the current position and rotation here\r\n         lastPosition = transform.position;\r\n         lastRotation = transform.rotation;\r\n"
                },
                {
                    "date": 1739324250161,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,8 +69,9 @@\n             }\r\n         }\r\n         // If let go of button, release object\r\n         else if (grabbedObject)\r\n+            Rigidbody rb = grabbedObject.GetComponent<Rigidbody>();\r\n             grabbedObject = null;\r\n             rb.isKinematic = false;\r\n \r\n         // Save the current position and rotation here\r\n"
                },
                {
                    "date": 1739324284512,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,13 +68,15 @@\n                 }\r\n             }\r\n         }\r\n         // If let go of button, release object\r\n-        else if (grabbedObject)\r\n+        else if (grabbedObject) \r\n+        \r\n+        {\r\n             Rigidbody rb = grabbedObject.GetComponent<Rigidbody>();\r\n             grabbedObject = null;\r\n             rb.isKinematic = false;\r\n-\r\n+        }\r\n         // Save the current position and rotation here\r\n         lastPosition = transform.position;\r\n         lastRotation = transform.rotation;\r\n     }\r\n"
                },
                {
                    "date": 1739326394625,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,9 +13,8 @@\n     public InputActionReference action;\r\n     bool grabbing = false;\r\n     Vector3 lastPosition;\r\n     Quaternion lastRotation;\r\n-    bool doubleRotation = false;\r\n     \r\n     \r\n \r\n     private void Start()\r\n"
                },
                {
                    "date": 1739326458207,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,9 +79,9 @@\n         lastPosition = transform.position;\r\n         lastRotation = transform.rotation;\r\n     }\r\n \r\n-        private Quaternion CalculateDeltaRotation()\r\n+    private Quaternion CalculateDeltaRotation()\r\n     {\r\n         Quaternion currentRotation = transform.rotation;\r\n         return currentRotation * Quaternion.Inverse(lastRotation);\r\n     }\r\n@@ -118,8 +118,9 @@\n \r\n         // Rotate object by delta rotation\r\n         obj.rotation = deltaRotation * obj.rotation;\r\n     }\r\n+    \r\n     private void OnTriggerEnter(Collider other)\r\n     {\r\n         // Make sure to tag grabbable objects with the \"grabbable\" tag\r\n         // You also need to make sure to have colliders for the grabbable objects and the controllers\r\n"
                },
                {
                    "date": 1739335097665,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,8 +10,10 @@\n     CustomGrab otherHand = null;\r\n     public List<Transform> nearObjects = new List<Transform>();\r\n     public Transform grabbedObject = null;\r\n     public InputActionReference action;\r\n+\r\n+    public InpurActionReference triggerRotation;\r\n     bool grabbing = false;\r\n     Vector3 lastPosition;\r\n     Quaternion lastRotation;\r\n     \r\n@@ -33,8 +35,9 @@\n     }\r\n \r\n     void Update()\r\n     {\r\n+        bool isGripPressed = gripAction.action.IsPressed();\r\n         grabbing = action.action.IsPressed();\r\n         if (grabbing)\r\n         {\r\n             // Grab nearby object or the object in the other hand\r\n"
                },
                {
                    "date": 1739335246021,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -35,9 +35,9 @@\n     }\r\n \r\n     void Update()\r\n     {\r\n-        bool isGripPressed = gripAction.action.IsPressed();\r\n+        bool isTriggerPressed = triggerRotation.action.IsPressed();\r\n         grabbing = action.action.IsPressed();\r\n         if (grabbing)\r\n         {\r\n             // Grab nearby object or the object in the other hand\r\n@@ -52,8 +52,13 @@\n                 Quaternion currentRotation = transform.rotation;\r\n                 Vector3 deltaPosition = currentPosition - lastPosition;\r\n                 Quaternion deltaRotation = currentRotation * Quaternion.Inverse(lastRotation);\r\n \r\n+                // If trigger is pressed, amplify the rotation\r\n+                if (isTriggerPressed) {\r\n+                    deltaRotation = AmplifyRotation(deltaRotation);\r\n+                }\r\n+\r\n                 // When grabbed by one hand\r\n                 if (!otherHand.grabbing || otherHand.grabbedObject != grabbedObject)\r\n                 {\r\n                     grabbedObject.position += deltaPosition;\r\n"
                },
                {
                    "date": 1739335266950,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,9 @@\n     public List<Transform> nearObjects = new List<Transform>();\r\n     public Transform grabbedObject = null;\r\n     public InputActionReference action;\r\n \r\n-    public InpurActionReference triggerRotation;\r\n+    public InputActionReference triggerRotation;\r\n     bool grabbing = false;\r\n     Vector3 lastPosition;\r\n     Quaternion lastRotation;\r\n     \r\n"
                },
                {
                    "date": 1739335723661,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,10 +10,8 @@\n     CustomGrab otherHand = null;\r\n     public List<Transform> nearObjects = new List<Transform>();\r\n     public Transform grabbedObject = null;\r\n     public InputActionReference action;\r\n-\r\n-    public InputActionReference triggerRotation;\r\n     bool grabbing = false;\r\n     Vector3 lastPosition;\r\n     Quaternion lastRotation;\r\n     \r\n@@ -35,9 +33,8 @@\n     }\r\n \r\n     void Update()\r\n     {\r\n-        bool isTriggerPressed = triggerRotation.action.IsPressed();\r\n         grabbing = action.action.IsPressed();\r\n         if (grabbing)\r\n         {\r\n             // Grab nearby object or the object in the other hand\r\n@@ -52,13 +49,8 @@\n                 Quaternion currentRotation = transform.rotation;\r\n                 Vector3 deltaPosition = currentPosition - lastPosition;\r\n                 Quaternion deltaRotation = currentRotation * Quaternion.Inverse(lastRotation);\r\n \r\n-                // If trigger is pressed, amplify the rotation\r\n-                if (isTriggerPressed) {\r\n-                    deltaRotation = AmplifyRotation(deltaRotation);\r\n-                }\r\n-\r\n                 // When grabbed by one hand\r\n                 if (!otherHand.grabbing || otherHand.grabbedObject != grabbedObject)\r\n                 {\r\n                     grabbedObject.position += deltaPosition;\r\n@@ -106,16 +98,8 @@\n         toObject = deltaRotation * toObject;\r\n         grabbedObject.position = transform.position + toObject;\r\n         grabbedObject.rotation = deltaRotation * grabbedObject.rotation;\r\n     }\r\n-\r\n-    private Quaternion AmplifyRotation(Quaternion rotation)\r\n-    {\r\n-        rotation.ToAngleAxis(out float angle, out Vector3 axis);\r\n-        angle *= 2;  // Double the rotation angle\r\n-        return Quaternion.AngleAxis(angle, axis);\r\n-    }\r\n-\r\n     private void ApplyTransformations(Transform obj, Vector3 deltaPosition, Quaternion deltaRotation)\r\n     {\r\n         obj.position += deltaPosition;  // Move object by delta position\r\n \r\n"
                },
                {
                    "date": 1739371556736,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -98,20 +98,8 @@\n         toObject = deltaRotation * toObject;\r\n         grabbedObject.position = transform.position + toObject;\r\n         grabbedObject.rotation = deltaRotation * grabbedObject.rotation;\r\n     }\r\n-    private void ApplyTransformations(Transform obj, Vector3 deltaPosition, Quaternion deltaRotation)\r\n-    {\r\n-        obj.position += deltaPosition;  // Move object by delta position\r\n-\r\n-        // Rotate object around its current position\r\n-        Vector3 toObject = obj.position - transform.position;\r\n-        toObject = deltaRotation * toObject;\r\n-        obj.position = transform.position + toObject;\r\n-\r\n-        // Rotate object by delta rotation\r\n-        obj.rotation = deltaRotation * obj.rotation;\r\n-    }\r\n     \r\n     private void OnTriggerEnter(Collider other)\r\n     {\r\n         // Make sure to tag grabbable objects with the \"grabbable\" tag\r\n"
                }
            ],
            "date": 1739226573092,
            "name": "Commit-0",
            "content": "using UnityEngine;\r\nusing UnityEngine.XR.Interaction.Toolkit;\r\n\r\npublic class CustomGrab : XRGrabInteractable\r\n{\r\n    private Vector3 initialAttachLocalPos;\r\n    private Quaternion initialAttachLocalRot;\r\n\r\n    public bool doubleRotationSpeed = false;\r\n    private XRBaseInteractor secondInteractor;\r\n    private Quaternion attachRotationDelta;\r\n\r\n    protected override void OnSelectEntered(SelectEnterEventArgs args)\r\n    {\r\n        base.OnSelectEntered(args);\r\n        if (selectingInteractor != null && secondInteractor == null)\r\n        {\r\n            // Save the initial attach points\r\n            initialAttachLocalPos = args.interactor.attachTransform.localPosition;\r\n            initialAttachLocalRot = args.interactor.attachTransform.localRotation;\r\n        }\r\n        else\r\n        {\r\n            secondInteractor = args.interactor;\r\n            attachRotationDelta = Quaternion.Inverse(initialAttachLocalRot) * args.interactor.attachTransform.localRotation;\r\n        }\r\n    }\r\n\r\n    protected override void OnSelectExited(SelectExitEventArgs args)\r\n    {\r\n        base.OnSelectExited(args);\r\n        if (args.interactor == secondInteractor)\r\n            secondInteractor = null;\r\n    }\r\n\r\n    public override void ProcessInteractable(XRInteractionUpdateOrder.UpdatePhase updatePhase)\r\n    {\r\n        if (isSelected && secondInteractor != null)\r\n        {\r\n            if (updatePhase == XRInteractionUpdateOrder.UpdatePhase.Dynamic)\r\n            {\r\n                // Calculate the position by averaging the position of both interactors\r\n                Vector3 positionDelta = (selectingInteractor.attachTransform.position + secondInteractor.attachTransform.position) / 2 - transform.position;\r\n                transform.position += positionDelta;\r\n\r\n                // Calculate the rotation by combining the rotations of both interactors\r\n                Quaternion rotationDelta = selectingInteractor.attachTransform.rotation * Quaternion.Inverse(initialAttachLocalRot);\r\n                Quaternion secondRotationDelta = secondInteractor.attachTransform.rotation * Quaternion.Inverse(attachRotationDelta);\r\n                transform.rotation = Quaternion.Lerp(rotationDelta, secondRotationDelta, 0.5f) * transform.rotation;\r\n\r\n                // Double the rotation if the feature is enabled\r\n                if (doubleRotationSpeed)\r\n                {\r\n                    Quaternion additionalRotation = Quaternion.AngleAxis(rotationDelta.eulerAngles.magnitude, rotationDelta.eulerAngles.normalized) * transform.rotation;\r\n                    transform.rotation = additionalRotation;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            base.ProcessInteractable(updatePhase);\r\n        }\r\n    }\r\n}\r\n"
        }
    ]
}